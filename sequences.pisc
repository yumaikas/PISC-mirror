: <int-seq> ( -- seq ) 
  0 :curr
  <dict> 
    [ t ] <<-has-next
    [ $curr ++curr ] <<-get-next
;

: filt-seq ( seq pred -- seq ) 
  :pred :seq
  <dict>
    [ $seq .has-next ] <<-has-next
    [ 
      $seq .get-next :item
      [ $item pred not $seq .has-next and ] [
        $seq .get-next :item
      ] while
      $item
    ] <<-get-next
;

: take-seq ( seq n -- elms ) 
  :n :seq $n [ $seq .get-next ] times
  # An alternative would be 
  # [ :seq ] dip [ $seq .get-next ] times
;

<int-seq> [ even? ] filt-seq 10 take-seq

/* Output:
0 <Integer> 
2 <Integer> 
4 <Integer> 
6 <Integer> 
8 <Integer> 
10 <Integer> 
12 <Integer> 
14 <Integer> 
16 <Integer> 
18 <Integer> 
*/